[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Josh Yamamoto",
    "section": "",
    "text": "Hello! I’m a Mathematics & Statistics undergraduate student at Reed College. My technical interests lie in bayesian statistics, small area estimation, and statistical software, and I’m especially passionate about propagating thoughtfullness and intentionality into how we do those things."
  },
  {
    "objectID": "blog-posts/blog2.html",
    "href": "blog-posts/blog2.html",
    "title": "Using the purrr function shortcuts in your own custom functions",
    "section": "",
    "text": "Functionals basics\n\nlibrary(purrr)\n\nFunctionals are defined as functions that take a function as input and return a vector as output. The simplest non-base R way to do this is by using a purrr::map_*() function. These functions simply apply the user specified function to each element in the input vector and returns an object with the same number of elements as the input.\n\nsquare <- function(x) x ^ 2\nmap_dbl(1:3, square)\n\n[1] 1 4 9\n\n\nWe can simplify this by making use of anyonymous functions and shortcuts. First we can define our function inside of map_dbl and since we don’t have to bind it to a name it is considered an anonymous function:\n\nmap_dbl(1:3, function(x) x ^ 2)\n\n[1] 1 4 9\n\n\nNext we can use a special purrr shortcut to simplify this code even further\n\nmap_dbl(1:3, ~ .x ^ 2)\n\n[1] 1 4 9\n\n\nTechnically it would be most correct to write\n\nmap_dbl(1:3,  ~ . ^ 2)\n\n[1] 1 4 9\n\n\nsince the convention with these formula objects is to use\n\n. for a single argument function\n.x and .y for a two argument function\n..1, ..2, ..3 , etc for functions with more arguments\n\nbut sometimes it’s nice to still see the x in the formula.\nEither way, this code is wonderfully clean and concise and it sure would be nice if we could write our own functions that use the same syntax. And the good news is that we can! The solution only relies on the use of the function purrr::as_mapper() which can convert a formula object into a function.\nTo demonstrate that functionality I’ll show a small toy example:\n\nfunc_formula <- ~ .x ^ 2\nfunc <- as_mapper(func_formula)\n\nfunc(2)\n\n[1] 4\n\n\nAnd actually, under the hood, purrr::map() is first applying this as_mapper() function to the user supplied function which explains why we can supply functions to map() in so many different ways.\n\npurrr::map\n\nfunction (.x, .f, ...) \n{\n    .f <- as_mapper(.f, ...)\n    .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n}\n<bytecode: 0x56386ec386d8>\n<environment: namespace:purrr>\n\n\nSo with this knowledge under our belt, we can write a custom function of our own that is able to use that clean and concise syntax that map() allows.\nAlthough this is certainly not a very useful function, it shows a very bare bones example of how you can write your own functions to use the purrr shortcut syntax!\n\nall_met <- function(.x, .f, ...){ \n  .f <- as_mapper(.f, ...)\n  \n  for (i in .x) { \n    if(!.f(i)) return(F)\n  }\n  return(T)\n}\n\nall_met(2:5, ~ .x > 1)\n\n[1] TRUE\n\nall_met(1:5, ~ .x > 1)\n\n[1] FALSE"
  },
  {
    "objectID": "blog-posts/blog1.html",
    "href": "blog-posts/blog1.html",
    "title": "ggplot, geometry, and visualizing probability",
    "section": "",
    "text": "I was recently given the following problems in one of my math classes\n\nLet \\(X\\) and \\(Y\\) be i.i.d \\(\\text{Unif}(0,1)\\) and define a variable \\(Z = ⌊X/Y⌋\\), where \\(⌊z⌋\\) denotes the greatest integer less than or equal to \\(z\\)\nFind the probability that Z is an odd number\n\nat first glance I had absolutely no idea how to solve this problem. And even as I started to understand what the question was asking I still didn’t really know how one would go about solving it.\nI knew that the problem could be rephrased as\nFind\n\\[P(\\text{Z odd}) = P(Z = 1) + P(Z = 3) + P(Z = 5) \\ +  \\ ...\\]\nSo I figured I might as well just try to solve for these first few probabilities and see if I could find a pattern.\nIf you think about it, if \\(X,Y\\) are i.i.d \\(\\text{Unif}(0,1)\\) then we can imagine each realization of X and Y being like the x and y coordinates of a random point in the cartesian product \\([0,1] \\times [0,1]\\). And if we want to get a rough sense for the probability that \\(Z = 1\\) then we can just generate many such coordinates and then see how many of these coordinates satisfy our condition. This is a lot of words and it might still be confusing so lets make a plot. We’ll write it as a function since we’ll want to make more of these plots later on:\n\nlibrary(tidyverse)\ndata_points <- tibble(\n  x = runif(15000, 0, 1),\n  y = runif(15000, 0, 1)\n)\nfloor_plot <- function(data, z) {\n  data %>% \n    ggplot(aes(x, y , color  = (floor(x/y) == {{ z }}))) +\n    geom_point(size = 1.5) +\n    scale_color_manual(values = c(\"midnightblue\", \"cyan4\")) +\n    theme_minimal()\n}\nfloor_plot(data_points, 1)\n\n\n\n\nand so since we know that the area of the entire square is just one, then the probability that \\(Z = 1\\) can be approximated by counting what fraction of the 10,000 points that we generated is in that cyan streak. Moreover we can imagine generating infinitely many points and coloring them accordingly, and in a monte carlo fashion, say that the probability that \\(Z = 1\\) is just the area of that cyan section. And once you get to see it visually it makes sense why this is the case.\nIn order to have \\(\\lfloor X/Y \\rfloor =1\\) then we certainly need \\(X > Y\\), since otherwise the floor is zero, but if we make X too big then we end up with 2 or 3 and so on. So we require that \\(X \\ge Y\\) but also that \\(X < 2Y\\). In other words, once X gets to be twice as large as Y, then the floor is larger than 1.\nAnd if we want to find \\(P(Z = 3)\\)?\n\nfloor_plot(data_points, 3)\n\n\n\n\nand \\(P(Z = 5)\\)?\n\nfloor_plot(data_points, 5)\n\n\n\n\nand how about all odd numbers? (which is what we’re really trying to find)\n\ndata_points %>% \n  ggplot(aes(x, y, color = (floor(x/y)%%2 == 1))) +\n  geom_point(size = 1.3) +\n  scale_color_manual(values = c(\"midnightblue\", \"cyan4\")) +\n  theme_minimal()\n\n\n\n\ncool right?\nBeyond being a pretty picture, we’re also most of the way towards solving the problem. Importantly though, the main idea here is that we slowly built up an understanding of the problem by using ggplot on a few small cases.\nWe can actually solve for this probability by writing it as a sum. Recall how we said that the conditions for \\(P(Z = 1)\\) were that \\(Y \\le X < 2Y\\), well similarly, the conditions for \\(P(Z = 3)\\) are that \\(3Y \\le X < 4Y\\) and the pattern continues.\nSo we can write the sum of all these triangles as\n\\[P(\\text{Z odd}) = \\sum_{i=1}^\\infty\\frac{1}{2}\\bigg(\\frac{1}{2i-1} - \\frac{1}{2i}\\bigg) = \\frac{\\ln(2)}{2} \\approx 0.34\\]\nwhich ends up being a very nice answer! thanks ggplot"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "stats + coding thoughts",
    "section": "",
    "text": "Using the purrr function shortcuts in your own custom functions\n\n\n\n\n\nand understanding purrr::map() more deeply along the way\n\n\n\n\n\n\nNov 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJob Searching…\n\n\n\n\n\n\n\n\n\n\n\n\nNov 14, 2022\n\n\n\n\n\n\n  \n\n\n\n\nggplot, geometry, and visualizing probability\n\n\n\n\n\na playful way to solve a complex probability problem\n\n\n\n\n\n\nOct 27, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "About this site"
  }
]