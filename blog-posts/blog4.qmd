---
title: "Function operators in R"
description: "writing a simple version of `safely`"
date: "11/26/22"
editor: visual
---

A function operator is defined as a function that takes any number of functions as input and returns a function as output. As a way to better understand how they work and why they work, I'll write a simple version of `purrr::safely()`. `safely()` is a really nice way to guard your functional programming against errors as it will allow your functionals to keep running even when they throw errors. I'll show it in action with a simple example

```{r}
library(purrr)
library(tidyverse)
library(rlang)

tests <- list(
  tibble(a = 1:10, b = 2:11),
  tibble(a = 4:15, b = 1:12),
  tibble(a = 1:5, c = 6:10)
)
```

```{r, eval = F}
map(tests, ~ .x["b"])

# Error in `.x["b"]`:
# ! Can't subset columns that don't exist.
# âœ– Column `b` doesn't exist.
# Backtrace:
#  1. purrr::map(tests, ~.x["b"])
#  2. global .f(.x[[i]], ...)
#  4. tibble:::`[.tbl_df`(.x, "b")
```

```{r}
out <- map(tests, safely( ~ .x["b"]))

out[[1]]
out[[3]]
```

We are now ready to write our own version of `safely()`

Essentially all that our simple version will do is that it will return a function that uses `tryCatch` on our original function and returns a list with the output and the error (if one occurs).

```{r}
simple_safely <- function(.f) {
  .f <- as_mapper(.f)
  
  function(...) {
    out <- tryCatch(
      {
      list(result = .f(...), error = NULL)
      },
      error = function(cond){
        list(result = NULL, error = cond)
      }
    )
  return(out)
  }
}

out2 <- map(tests, simple_safely(~ .x["b"]))
```

This seems simple enough, but at least for me it was unsatisfying that I didn't really understand what it was about R as a programming language that allowed function operations to work. Luckily we can dig a little bit into how this works by exploring the various environments associated with this procedure.

We'll start by creating a function that is a safe version of the function `mean()`

```{r}
safe_mean <- simple_safely(mean)
```

We can start by just looking at `safe_mean` itself

```{r}
safe_mean
```

Just looking at this output is fairly confusing because it just looks like the body of `simple_safely()` and it's unclear how the function knows how to find `.f`
